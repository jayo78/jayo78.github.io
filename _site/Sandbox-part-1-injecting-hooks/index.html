<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.19.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Sandbox part 1 - injecting hooks -</title>
<meta name="description" content="In this 2 part series I will walk through creating a simple userland sandbox that is able to peak inside the functionality of a windows executable. It does this by injecting a monitor DLL, whos job is to install inline API hooks that intercept and report any calls made by the executable. This type of software is widely used to examine malicious programs dynamically or ensure a secure execution environment when dealing with untrusted users. By building your own sandbox you will be introduced to some really cool memory hacking techniques seen in malware and game cheats. This project is easily adaptable and I suggest the reader implement their own design.">


  <meta name="author" content="Jayson Hurst">


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="">
<meta property="og:title" content="Sandbox part 1 - injecting hooks">
<meta property="og:url" content="http://localhost:4000/Sandbox-part-1-injecting-hooks/">


  <meta property="og:description" content="In this 2 part series I will walk through creating a simple userland sandbox that is able to peak inside the functionality of a windows executable. It does this by injecting a monitor DLL, whos job is to install inline API hooks that intercept and report any calls made by the executable. This type of software is widely used to examine malicious programs dynamically or ensure a secure execution environment when dealing with untrusted users. By building your own sandbox you will be introduced to some really cool memory hacking techniques seen in malware and game cheats. This project is easily adaptable and I suggest the reader implement their own design.">







  <meta property="article:published_time" content="2020-07-01T00:00:00-04:00">





  

  


<link rel="canonical" href="http://localhost:4000/Sandbox-part-1-injecting-hooks/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "jayo78",
      "url": "http://localhost:4000/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title=" Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/logo.png" alt=""></a>
        
        <a class="site-title" href="/">
          jayo78
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/">Home</a>
            </li><li class="masthead__menu-item">
              <a href="/year-archive/">Posts</a>
            </li><li class="masthead__menu-item">
              <a href="/about/">About</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      


  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="http://localhost:4000/" itemprop="item"><span itemprop="name">Home</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        <li class="current">Sandbox part 1 - injecting hooks</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/images/avatar.jpg" alt="Jayson Hurst" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">Jayson Hurst</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Aspiring security researcher<br />Student at UMD</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Philadelphia, PA</span>
        </li>
      

      
        
          
            <li><a href="https://www.linkedin.com/in/jayo78" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">LinkedIn</span></a></li>
          
        
          
            <li><a href="https://github.com/jayo78" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
      

      

      
        <li>
          <a href="mailto:jhurst1@terpmail.umd.edu">
            <meta itemprop="email" content="jhurst1@terpmail.umd.edu" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Sandbox part 1 - injecting hooks">
    <meta itemprop="description" content="In this 2 part series I will walk through creating a simple userland sandbox that is able to peak inside the functionality of a windows executable. It does this by injecting a monitor DLL, whos job is to install inline API hooks that intercept and report any calls made by the executable. This type of software is widely used to examine malicious programs dynamically or ensure a secure execution environment when dealing with untrusted users. By building your own sandbox you will be introduced to some really cool memory hacking techniques seen in malware and game cheats. This project is easily adaptable and I suggest the reader implement their own design.">
    <meta itemprop="datePublished" content="2020-07-01T00:00:00-04:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Sandbox part 1 - injecting hooks
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  9 minute read

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
        <p>In this 2 part series I will walk through creating a simple userland sandbox that is able to peak inside the functionality of a windows executable. It does this by injecting a monitor DLL, whos job is to install inline API hooks that intercept and report any calls made by the executable. This type of software is widely used to examine malicious programs dynamically or ensure a secure execution environment when dealing with untrusted users. By building your own sandbox you will be introduced to some really cool memory hacking techniques seen in malware and game cheats. This project is easily adaptable and I suggest the reader implement their own design.</p>

<h4 id="prerequisites-and-resources">Prerequisites and Resources</h4>

<p>You will need to understand:</p>

<ul>
  <li><a href="https://support.microsoft.com/en-us/help/815065/what-is-a-dll">DLLs</a>, <a href="https://docs.microsoft.com/en-us/windows/win32/procthread/processes-and-threads">Windows processes and threads</a>, <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">PE file format</a></li>
  <li>Windows API hooking - see resources below or my blog post “WinAPI Hooking Basics”</li>
  <li>C/C++, basic x86, debugging</li>
</ul>

<p>Resources I used:</p>

<ul>
  <li><a href="http://www.binaryguard.com/bgc/malware/sandbox/2015/11/09/dissecting_inline_hooks.html">dissecting inline hooks</a></li>
  <li><a href="http://jbremer.org/x86-api-hooking-demystified/">x86 api hooking demystified</a></li>
  <li><a href="https://www.malwaretech.com/2015/01/inline-hooking-for-programmers-part-1.html">inline hooking for programmers</a></li>
</ul>

<h4 id="so-what-is-a-sandbox">So what is a sandbox?</h4>

<p>A sandbox is designed to examine the behavior of an executable and is largely used in Cybersecurity solutions for analyzing malware. There are a few open source projects like <a href="https://cuckoosandbox.org/">Cuckoo</a>.</p>

<p>The idea is to run a program in a controlled environment to see what it attempts to do. A native executable will need to reach out to the host operating system in order to have any functionality. For example, it might need to manipulate a file using the I/O functions or use sockets to connect to remote servers. In order to intercept these calls to the operating system, a userland sandbox will need to sit in the middle of this communication.</p>

<p>We will be building a sandbox for Windows executables, which have the PE file <a href="https://docs.microsoft.com/en-us/windows/win32/debug/pe-format">format</a>. The Windows API (win32 API) allows for userland programs to interact with the Windows OS by providing functions in shared libraries called <em>Dynamically Linked Libraries</em>. The sandbox will need to monitor these functions.</p>

<p><img src="../assets/images/SandboxPart1/Sandbox.PNG" alt="Sandbox" class="align-center" /></p>

<p>Since every process essentially has their very own copy of Windows DLLs needed to execute, our sandbox will need to be injected into the executable’s process that we want to examine. Once injected the sandbox can insert changes known as <em>hooks</em> into the imported DLL functions that will now be used by the executable.</p>

<p>I will focus my attention on the actual implementation of injecting and installing hooks. There are extensive recourses out there that do a better job than I would at explaining topics like processes, threads, OS internals, etc. I used many resources that I’ll share and I encourage the reader to extend your own research beyond this article where you find gaps in knowledge.</p>

<h4 id="process-injection">Process Injection</h4>

<p>Processes are more than a space for a program to execute in. There is a lot of behind the scenes work done by the Windows OS in terms of the security of a program, communication with other processes, and access to shared recourses. The birth of a process involves the mapping of a program’s memory on disk to virtual memory where it can begin executing. Windows separates address spaces using virtualization so they don’t bump into each other’s memory and so it can easily interface with each one individually - read <a href="https://answers.microsoft.com/en-us/windows/forum/windows_10-performance/physical-and-virtual-memory-in-windows-10/e36fb5bc-9ac8-49af-951c-e7d39b979938?auth=1">here</a>.</p>

<p>Knowing this OS functionality we can now begin looking at ways a process can access another processes memory using functions provided by the Windows API. I highly recommend checking out this <a href="https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process">post</a> on common process injection techniques. There are more in depth articles out there outlining many injection methods - see <a href="https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All-wp.pdf">here</a> - but for our sandbox we will be using <a href="http://blog.opensecurityresearch.com/2013/01/windows-dll-injection-basics.html">DLL injection</a>.</p>

<p>We first need to open the executable we would like to examine, using <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa">CreateProcess</a>. This function lets us create a child process in a suspended, which will now let us inject and install hooks before resuming its main thread. We can utilize <a href="https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread">CreateRemoteThread</a> and <a href="https://docs.microsoft.com/en-us/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya">LoadLibraryA</a> to load our hooking DLL into the process.</p>

<p><img src="../assets/images/SandboxPart2/DLL_injection.PNG" alt="injection" class="align-center" /></p>

<p>Here you can see the two components: the injector and the DLL that will be injected. The injector creates the process in suspended state and then starts a remote thread inside the new process. This remote thread then calls out to LoadLibrary which loads our DLL into the process space where we can start installing hooks.</p>

<h4 id="the-injector">The Injector</h4>

<p>Coding our own injector is actually quite simple, here is a snippet that shows what the diagram above depicts:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
** Create the process as suspended - main thread created but no DLLs loaded
*/</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CreateProcess</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">targetExe</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">CREATE_SUSPENDED</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">si</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pi</span><span class="p">))</span> 
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"CreateProcess failed: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

<span class="cm">/* 
** inject the process that we created 
*/</span>
    <span class="n">inject_DLL</span><span class="p">(</span><span class="n">dllPath</span><span class="p">,</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">);</span>

<span class="cm">/*
** Resume the suspended process now with our DLL injected
*/</span>
    <span class="n">ResumeThread</span><span class="p">(</span><span class="n">pi</span><span class="p">.</span><span class="n">hThread</span><span class="p">);</span>
    <span class="n">WaitForSingleObject</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span><span class="p">,</span> <span class="n">INFINITE</span> <span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hProcess</span> <span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span> <span class="n">pi</span><span class="p">.</span><span class="n">hThread</span> <span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

</code></pre></div></div>

<p>Lets take a look at our defined <code class="language-plaintext highlighter-rouge">inject_DLL</code> function. It takes the path to our DLL that we would like to inject and a handle to the process we created. To start out we will need the LoadLibrary function address, which can be found inside the kernel32 library, <code class="language-plaintext highlighter-rouge">kernel32.dll</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kernel32</span><span class="o">=</span> <span class="n">GetModuleHandle</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"kernel32.dll"</span><span class="p">));</span>
<span class="n">loadlibrary</span><span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">kernel32</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">"LoadLibraryA"</span><span class="p">));</span>
</code></pre></div></div>

<p>Its important to point out here that the LoadLibraryA function will always be loaded at the same address in each process. This means we can find the address in our injector process and it will be the same when executing in our remote thread. Now we must allocate and write a patch to the remote process so we can start a thread at that address.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lpBaseAddress</span><span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pathLen</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">lpBaseAddress</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"VirtualAllocEx failed: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">lpBaseAddress</span><span class="p">,</span> <span class="n">dllPath</span><span class="p">,</span> <span class="n">pathLen</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"WriteProcessMemory failed: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</code></pre></div></div>

<p>We are using <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex">VirtualAllocEx</a> and then <a href="https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory">WriteProcessMemory</a> to write the full path of our DLL that we would like to inject into the process.  When creating our remote thread we can specify a startup routine - a function that exists inside the process - that will use the DLL path as an argument.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">hRemoteThread</span><span class="o">=</span> <span class="n">CreateRemoteThread</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">LPTHREAD_START_ROUTINE</span><span class="p">)(</span><span class="n">VOID</span> <span class="o">*</span><span class="p">)</span><span class="n">loadlibrary</span><span class="p">,</span> <span class="n">lpBaseAddress</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">hRemoteThread</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"CreateRemoteThread failed: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</code></pre></div></div>

<p>Since we know the address of LoadLibrary we can use it as a startup routine to load our DLL path. Now that its loaded, our DLL will begin to execute at a defined entry point. Here is the full function:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">inject_DLL</span><span class="p">(</span><span class="n">TCHAR</span> <span class="o">*</span><span class="n">dllPath</span><span class="p">,</span> <span class="n">HANDLE</span> <span class="n">process</span><span class="p">)</span>
<span class="p">{</span>
<span class="cm">/*
** Variable declarations
*/</span>
    <span class="n">LPVOID</span> <span class="n">lpBaseAddress</span><span class="p">;</span>
    <span class="n">HANDLE</span> <span class="n">hRemoteThread</span><span class="p">;</span>
    <span class="n">HMODULE</span> <span class="n">kernel32</span><span class="p">;</span>
    <span class="n">FARPROC</span> <span class="n">loadlibrary</span><span class="p">;</span>
    <span class="n">SIZE_T</span> <span class="n">pathLen</span><span class="p">;</span>
    
<span class="cm">/*
** Initialize variables
*/</span>
    <span class="n">lpBaseAddress</span><span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">hRemoteThread</span><span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">loadlibrary</span><span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 
    <span class="n">kernel32</span><span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">pathLen</span><span class="o">=</span> <span class="n">_tcslen</span><span class="p">(</span><span class="n">dllPath</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TCHAR</span><span class="p">);</span>

    <span class="n">kernel32</span><span class="o">=</span> <span class="n">GetModuleHandle</span><span class="p">(</span><span class="n">_T</span><span class="p">(</span><span class="s">"kernel32.dll"</span><span class="p">));</span>
    <span class="n">loadlibrary</span><span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">kernel32</span><span class="p">,</span> <span class="n">_T</span><span class="p">(</span><span class="s">"LoadLibraryA"</span><span class="p">));</span>

<span class="cm">/*
** Allocate memory and write the dll path that will be injected
*/</span>
    <span class="n">lpBaseAddress</span><span class="o">=</span> <span class="n">VirtualAllocEx</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pathLen</span><span class="p">,</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lpBaseAddress</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"VirtualAllocEx failed: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="n">lpBaseAddress</span><span class="p">,</span> <span class="n">dllPath</span><span class="p">,</span> <span class="n">pathLen</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"WriteProcessMemory failed: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="cm">/*
** Create a thread that will load the dll path using LoadLibrary as a start up routine
*/</span> 
    <span class="n">hRemoteThread</span><span class="o">=</span> <span class="n">CreateRemoteThread</span><span class="p">(</span><span class="n">process</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">LPTHREAD_START_ROUTINE</span><span class="p">)(</span><span class="n">VOID</span> <span class="o">*</span><span class="p">)</span><span class="n">loadlibrary</span><span class="p">,</span> <span class="n">lpBaseAddress</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hRemoteThread</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"CreateRemoteThread failed: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="cm">/*
** Clean up
*/</span>
    <span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hRemoteThread</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
    <span class="n">CloseHandle</span><span class="p">(</span><span class="n">hRemoteThread</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="hooking-from-within">Hooking from within</h4>

<p>The injected DLL will need to install hooks from inside the target process, so lets look at how DLLs can be developed. DLLs can be attached to by a process and its threads in order to execute needed functionality, usually through an exported function. A normal use would be to call <code class="language-plaintext highlighter-rouge">LoadLibrary</code> on the DLL to get a handle and then <code class="language-plaintext highlighter-rouge">GetProcAddress</code> to find the desired exported function. The point of the switch cases, seen in <code class="language-plaintext highlighter-rouge">DllMain</code> below, is so the developer has a chance to set up structures/internals before an exported function is called. We won’t be exporting functions but will instead do our hooking from the entry point, which isn’t necessarily good <a href="https://docs.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices">practice</a>.</p>

<p>For a quick demo we will use the same MessageBoxA hook from <a href="https://github.com/jayo78/basic-hooking/blob/master/hook_v2.cpp">“WinAPI Hooking Basics”</a>, but this time it will be injected by our injector into a sample program.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
</span>
<span class="cp">#pragma comment(lib,"user32.lib")
</span>
<span class="k">typedef</span> <span class="nf">int</span> <span class="p">(</span><span class="n">WINAPI</span> <span class="o">*</span><span class="n">defTrampolineFunc</span><span class="p">)(</span><span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span> <span class="n">LPCSTR</span> <span class="n">lpText</span><span class="p">,</span> <span class="n">LPCSTR</span> <span class="n">lpCaption</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">uType</span><span class="p">);</span>
<span class="n">LPVOID</span> <span class="n">trampoline_address</span><span class="p">;</span> 

<span class="c1">// The proxy function we will jump to after the hook has been installed</span>
<span class="kt">int</span> <span class="kr">__stdcall</span> <span class="nf">proxy_function</span><span class="p">(</span><span class="n">HWND</span> <span class="n">hWnd</span><span class="p">,</span> <span class="n">LPCSTR</span> <span class="n">lpText</span><span class="p">,</span> <span class="n">LPCSTR</span> <span class="n">lpCaption</span><span class="p">,</span> <span class="n">UINT</span> <span class="n">uType</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"----------intercepted call to MessageBoxA----------</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Text: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">LPCSTR</span><span class="p">)</span><span class="n">lpText</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">Caption: "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">LPCSTR</span><span class="p">)</span><span class="n">lpCaption</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="c1">// pass to the trampoline with altered arguments which will then return to MessageBoxA</span>
    <span class="n">defTrampolineFunc</span> <span class="n">trampoline</span><span class="o">=</span> <span class="p">(</span><span class="n">defTrampolineFunc</span><span class="p">)</span><span class="n">trampoline_address</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">trampoline</span><span class="p">(</span><span class="n">hWnd</span><span class="p">,</span> <span class="s">"yeet"</span><span class="p">,</span> <span class="s">"yeet"</span><span class="p">,</span> <span class="n">uType</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">install_hook</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">HINSTANCE</span> <span class="n">hinstLib</span><span class="p">;</span>
    <span class="n">VOID</span> <span class="o">*</span><span class="n">proxy_address</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="o">*</span><span class="n">relative_offset</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="o">*</span><span class="n">hook_address</span><span class="p">;</span>
    <span class="n">DWORD</span> <span class="n">src</span><span class="p">;</span> 
    <span class="n">DWORD</span> <span class="n">dst</span><span class="p">;</span>
    <span class="n">CHAR</span> <span class="n">patch</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">char</span> <span class="n">saved_buffer</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="c1">// buffer to save the original bytes</span>
    <span class="n">FARPROC</span> <span class="n">function_address</span><span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="c1">// 1. get memory address of the MessageBoxA function from user32.dll </span>
    <span class="n">hinstLib</span><span class="o">=</span> <span class="n">LoadLibraryA</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"user32.dll"</span><span class="p">));</span>
    <span class="n">function_address</span><span class="o">=</span> <span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hinstLib</span><span class="p">,</span> <span class="s">"MessageBoxA"</span><span class="p">);</span>

    <span class="c1">// 2. save the first 5 bytes into saved_buffer</span>
    <span class="n">ReadProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="n">function_address</span><span class="p">,</span> <span class="n">saved_buffer</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 3. overwrite the first 5 bytes with a jump to proxy_function</span>
    <span class="n">proxy_address</span><span class="o">=</span> <span class="o">&amp;</span><span class="n">proxy_function</span><span class="p">;</span>
    <span class="n">src</span><span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span><span class="n">function_address</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span> 
    <span class="n">dst</span><span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span><span class="p">)</span><span class="n">proxy_address</span><span class="p">;</span>
    <span class="n">relative_offset</span><span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span> <span class="o">*</span><span class="p">)(</span><span class="n">dst</span><span class="o">-</span><span class="n">src</span><span class="p">);</span> 

    <span class="n">memcpy</span><span class="p">(</span><span class="n">patch</span><span class="p">,</span> <span class="s">"</span><span class="se">\xE9</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">patch</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">relative_offset</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

    <span class="n">WriteProcessMemory</span><span class="p">(</span><span class="n">GetCurrentProcess</span><span class="p">(),</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">function_address</span><span class="p">,</span> <span class="n">patch</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="c1">// 4. Build the trampoline</span>
    <span class="n">trampoline_address</span><span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
    <span class="n">hook_address</span><span class="o">=</span> <span class="p">(</span><span class="n">DWORD</span> <span class="o">*</span><span class="p">)((</span><span class="n">DWORD</span><span class="p">)</span><span class="n">function_address</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">)</span><span class="n">trampoline_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saved_buffer</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">)</span><span class="n">trampoline_address</span> <span class="o">+</span> <span class="mi">5</span><span class="p">,</span> <span class="s">"</span><span class="se">\x68</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">)</span><span class="n">trampoline_address</span> <span class="o">+</span> <span class="mi">6</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hook_address</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">((</span><span class="n">BYTE</span> <span class="o">*</span><span class="p">)</span><span class="n">trampoline_address</span> <span class="o">+</span> <span class="mi">10</span><span class="p">,</span> <span class="s">"</span><span class="se">\xC3</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span> <span class="p">(</span><span class="n">HINSTANCE</span> <span class="k">const</span> <span class="n">instance</span><span class="p">,</span> <span class="n">DWORD</span> <span class="k">const</span> <span class="n">reason</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="k">const</span> <span class="n">reserved</span><span class="p">)</span>  
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">reason</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">:</span>
            <span class="n">MessageBoxA</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">"process attached"</span><span class="p">,</span> <span class="s">"Monitor"</span><span class="p">,</span> <span class="n">MB_OK</span><span class="p">);</span>
            <span class="n">MessageBoxA</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">"installing hook"</span><span class="p">,</span> <span class="s">"Monitor"</span><span class="p">,</span> <span class="n">MB_OK</span><span class="p">);</span>
            <span class="n">install_hook</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="n">DLL_THREAD_ATTACH</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">DLL_PROCESS_DETACH</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">DLL_THREAD_DETACH</span><span class="p">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>  
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">DllMain</code> is called upon a process/thread attach or detach and is the DLL’s entry point. <code class="language-plaintext highlighter-rouge">LoadLibrary</code> triggers this entry point and will execute the code in the <code class="language-plaintext highlighter-rouge">DLL_PROCESS_ATTACH</code> case, see <a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/mscs/implementing-dllmain">here</a>.</p>

<p>We’ll inject it into a simple test program that you will need to compile:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;windows.h&gt;
#pragma comment(lib,"user32.lib")
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">MessageBoxA</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">,</span> <span class="n">MB_OK</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To inject into the compiled executable using the injector we first need to compile our DLL code to an actual DLL. Executables (.exe extension) and DLLs (.dll extension) share the same PE file format but serve different <a href="https://stackoverflow.com/questions/1210873/difference-between-dll-and-exe">purposes</a> and are compiled differently. I use Microsoft’s compiler, <a href="https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options?view=vs-2019">MSVC</a> from the <a href="https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=vs-2019">command line</a>. To compile a DLL we must specify the <a href="https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library?view=vs-2019">/LD</a> option.</p>

<p>Once we have our DLL, use the injector (injector.exe) like so: <code class="language-plaintext highlighter-rouge">injector.exe &lt;test.exe&gt; &lt;path to DLL&gt;</code>. View the injector and DLL code on <a href="https://github.com/jayo78/basic-hooking/tree/master/injection">github</a>.</p>

<h4 id="conclusion">Conclusion</h4>

<p>In this first of two posts on building a sandbox, we walked through DLL injection for the purpose of installing hooks into a remote process. Don’t worry, we will be hooking much more than MessageBoxA. In part 2 we will implement the minhook library as a hooking engine to hook and monitor a wide variety of windows functions.</p>

        
      </section>

      <footer class="page__meta">
        
        


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2020-07-01T00:00:00-04:00">July 1, 2020</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=Sandbox+part+1+-+injecting+hooks%20http%3A%2F%2Flocalhost%3A4000%2FSandbox-part-1-injecting-hooks%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=http%3A%2F%2Flocalhost%3A4000%2FSandbox-part-1-injecting-hooks%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=http%3A%2F%2Flocalhost%3A4000%2FSandbox-part-1-injecting-hooks%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/WinAPI-Hooking-basics/" class="pagination--pager" title="WinAPI Hooking Basics
">Previous</a>
    
    
      <a href="/Sandbox-part-2-hooking-engine/" class="pagination--pager" title="Sandbox part 2 - hooking engine
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/Sandbox-part-2-hooking-engine/" rel="permalink">Sandbox part 2 - hooking engine
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  4 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">In part 2 we will first deal with implementing the open-source hooking library, minhook, as our hooking engine to ensure more reliable and efficient hooks. T...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/WinAPI-Hooking-basics/" rel="permalink">WinAPI Hooking Basics
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  7 minute read

</p>
    
    <p class="archive__item-excerpt" itemprop="description">API hooking has been cover exhaustedly over the past decade so this is my attempt at a logical tutorial for the reader and for the purpose of better understa...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
          <li><a href="https://github.com/jayo78" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2020 jayo78. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>










  </body>
</html>
